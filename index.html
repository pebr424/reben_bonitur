<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Reben-Bonitur (PWA Demo)</title>

  <style>
    body { margin:0; font-family:system-ui, -apple-system,Segoe UI, Roboto, "Helvetica Neue", Arial; }
    #map { height:55vh; }
    .toolbar { padding:8px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .panel { padding:8px; }
    .point { cursor:pointer; padding:6px; border-bottom:1px solid #eee; }
    input, button, select, textarea { font:inherit; padding:6px; }
    .photo-thumb { max-width:100px; max-height:80px; margin:4px; }
    .small { font-size:0.9rem; }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>
<body>
  <div class="toolbar">
    <button id="btn-set-row">Reihe setzen (2 Punkte)</button>
    <label class="small">Stock-Abstand (m): <input id="input-spacing" type="number" value="1" min="0.1" step="0.1" style="width:70px"></label>
    <label class="small">Reihenabstand (m): <input id="input-rowspacing" type="number" value="2" min="0.1" step="0.1" style="width:70px"></label>
    <label class="small">Richtung: 
      <select id="select-dir"><option value="right">rechts</option><option value="left">links</option><option value="both">beide</option></select>
    </label>
    <button id="btn-generate">Stöcke generieren</button>
    <button id="btn-export">Export CSV</button>
    <button id="btn-clear">DB löschen</button>
    <span id="status"></span>
  </div>

  <div id="map"></div>
  <div class="panel">
    <h3>Liste (tippe Punkt auf Karte oder hier)</h3>
    <div id="list"></div>
  </div>

  <!-- Detail Modal -->
  <div id="modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.4); align-items:center; justify-content:center;">
    <div style="background:#fff; padding:12px; width:92%; max-width:480px; border-radius:8px;">
      <h3 id="modal-title">Stock</h3>
      <div id="modal-body"></div>
      <div style="display:flex; gap:8px; margin-top:8px; justify-content:flex-end;">
        <button id="btn-save">Speichern</button>
        <button id="btn-close">Schließen</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // --- IndexedDB Wrapper ---
    const DB_NAME = 'reben-bonitur-v1';
    const STORE = 'stocks';
    function openDB(){
      return new Promise((res,rej)=>{
        const r = indexedDB.open(DB_NAME,1);
        r.onupgradeneeded = e => { const db = e.target.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE,{keyPath:'id'}); };
        r.onsuccess = e => res(e.target.result);
        r.onerror = e => rej(e.target.error);
      });
    }
    async function putStock(obj){ const db = await openDB(); const tx = db.transaction(STORE,'readwrite'); tx.objectStore(STORE).put(obj); return new Promise((r,rej)=>{tx.oncomplete=r;tx.onerror=rej}); }
    async function getAll(){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction(STORE,'readonly'); const req = tx.objectStore(STORE).getAll(); req.onsuccess = ()=>res(req.result); req.onerror = ()=>rej(req.error); }); }
    async function clearAll(){ const db = await openDB(); const tx = db.transaction(STORE,'readwrite'); tx.objectStore(STORE).clear(); return new Promise((r,rej)=>{tx.oncomplete=r;tx.onerror=rej}); }

    // --- Map Setup ---
    const map = L.map('map').setView([48.0, 8.0], 16);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);

    let tempMarkers = [];
    let generatedPoints = [];
    const markersLayer = L.layerGroup().addTo(map);

    document.getElementById('btn-set-row').onclick = ()=>{
      tempMarkers.forEach(m=>map.removeLayer(m)); tempMarkers = [];
      map.once('click', e=>{
        const m1 = L.marker(e.latlng).addTo(map); tempMarkers.push(m1);
        map.once('click', e2=>{
          const m2 = L.marker(e2.latlng).addTo(map); tempMarkers.push(m2);
          const poly = L.polyline([m1.getLatLng(), m2.getLatLng()]).addTo(map);
          tempMarkers.push(poly);
          setStatus('Punkte gesetzt. Jetzt auf "Stöcke generieren" klicken.');
        });
      });
      setStatus('Klicke zwei Punkte auf der Karte, um die Reihe zu definieren.');
    };

    function setStatus(s){ document.getElementById('status').textContent = s; setTimeout(()=>{ if(document.getElementById('status').textContent===s) document.getElementById('status').textContent=''; },4000); }

    function toRad(d){ return d*Math.PI/180; }
    function toDeg(d){ return d*180/Math.PI; }

    function destPoint(lat, lon, bearingDeg, distMeters){
      const R = 6378137.0;
      const br = toRad(bearingDeg);
      const lat1 = toRad(lat), lon1 = toRad(lon);
      const dR = distMeters / R;
      const lat2 = Math.asin(Math.sin(lat1)*Math.cos(dR) + Math.cos(lat1)*Math.sin(dR)*Math.cos(br));
      const lon2 = lon1 + Math.atan2(Math.sin(br)*Math.sin(dR)*Math.cos(lat1), Math.cos(dR)-Math.sin(lat1)*Math.sin(lat2));
      return [toDeg(lat2), toDeg(lon2)];
    }

    function bearingBetween(a,b){
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat); const dLon = toRad(b.lng-a.lng);
      const y = Math.sin(dLon)*Math.cos(lat2);
      const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
      return (toDeg(Math.atan2(y,x))+360)%360;
    }

    // --- Utility: offset point perpendicular by meters (approx) ---
    function offsetPoint(lat, lng, bearingDeg, offsetMeters){
      // Move perpendicular (bearing+90) by offsetMeters
      const perp = (bearingDeg + 90) % 360;
      return destPoint(lat, lng, perp, offsetMeters);
    }

    // --- Generate stocks for base row + parallels ---
    document.getElementById('btn-generate').onclick = async ()=>{
      const pts = tempMarkers.filter(p=>p instanceof L.Marker).map(m=>m.getLatLng());
      if(pts.length<2){ setStatus('Bitte zuerst zwei Punkte setzen.'); return; }

      const baseStart = pts[0];
      const baseEnd   = pts[1];
      const spacing = parseFloat(document.getElementById('input-spacing').value) || 1;
      const rowSpacing = parseFloat(document.getElementById('input-rowspacing').value) || 2;
      const dir = document.getElementById('select-dir').value; // right,left,both
      const numExtra = parseInt(prompt('Wieviele zusätzliche parallele Reihen? (0 = nur diese)')||0);

      const allRows = [];
      allRows.push({start:baseStart, end:baseEnd, label:1});

      const bearingBase = bearingBetween(baseStart, baseEnd);

      function pushOffset(i, side){ // side = +1 right, -1 left
        const off = rowSpacing * i * side;
        const p1 = offsetPoint(baseStart.lat, baseStart.lng, bearingBase, off);
        const p2 = offsetPoint(baseEnd.lat, baseEnd.lng, bearingBase, off);
        allRows.push({start:{lat:p1[0], lng:p1[1]}, end:{lat:p2[0], lng:p2[1]}, label: allRows.length+1});
      }

      for(let i=1;i<=numExtra;i++){
        if(dir==='right' || dir==='both') pushOffset(i, +1);
        if(dir==='left'  || dir==='both') pushOffset(i, -1);
      }

      generatedPoints = [];
      markersLayer.clearLayers();

      for (let rIndex = 0; rIndex < allRows.length; rIndex++){
        const row = allRows[rIndex];
        const b = bearingBetween(row.start, row.end);
        const distTotal = map.distance(row.start, row.end);
        const count = Math.max(1, Math.round(distTotal/spacing) + 1);

        for(let i=0;i<count;i++){
          const d = i*spacing;
          const [lat,lon] = destPoint(row.start.lat, row.start.lng, b, d);
          const id = `R${rIndex+1}-S${i+1}`;
          const marker = L.circleMarker([lat,lon], {radius:6, color:'#2a9d8f'}).addTo(markersLayer);
          marker.__meta = {id, index:i+1, row:rIndex+1, lat, lon};
          marker.on('click', ()=> openDetail(marker.__meta));
          generatedPoints.push(marker.__meta);
        }
      }

      await saveInitial(generatedPoints);
      refreshList();
      setStatus(`Generiert ${generatedPoints.length} Stöcke in ${allRows.length} Reihen.`);
    };

    async function saveInitial(points){
      for(const p of points){
        const obj = { id: p.id, index: p.index, row: p.row, lat: p.lat, lon: p.lon, photos: [], last: null, created: new Date().toISOString() };
        await putStock(obj);
      }
    }

    async function refreshList(){
      const all = await getAll();
      const list = document.getElementById('list'); list.innerHTML='';
      all.sort((a,b)=>{
        if(a.row !== b.row) return a.row - b.row;
        return a.index - b.index;
      });
      for(const s of all){ const el = document.createElement('div'); el.className='point'; el.textContent = `${s.id} — R${s.row} S${s.index}`; el.onclick = ()=> openDetail(s); list.appendChild(el); }
    }

    // modal / detail
    function openDetail(meta){
      (async ()=>{
        let record;
        const all = await getAll();
        record = all.find(x=>x.id===meta.id) || meta;
        const title = document.getElementById('modal-title'); title.textContent = record.id || 'Stock';
        const body = document.getElementById('modal-body');
        body.innerHTML = `
          <div>Row: ${record.row ?? ''} — Index: ${record.index ?? ''}</div>
          <div>Lat: ${record.lat?.toFixed(6) ?? ''} Lon: ${record.lon?.toFixed(6) ?? ''}</div>
          <label>Wuchs (1-5): <input id="f-wuchs" type="number" min="1" max="5" value="${(record.last||{}).wuchs||''}"></label><br>
          <label>Gesundheit (1-5): <input id="f-gesund" type="number" min="1" max="5" value="${(record.last||{}).gesund||''}"></label><br>
          <label>Reife (1-5): <input id="f-reife" type="number" min="1" max="5" value="${(record.last||{}).reife||''}"></label><br>
          <label>Kommentar:<br><textarea id="f-komm">${(record.last||{}).kom || ''}</textarea></label><br>
          <label>Foto: <input id="f-photo" type="file" accept="image/*" capture="environment"></label>
          <div id="thumbs"></div>
        `;
        if(record.photos) for(const p of record.photos){ const img = document.createElement('img'); img.src = p; img.className='photo-thumb'; document.getElementById('thumbs').appendChild(img); }
        document.getElementById('modal').style.display='flex';

        document.getElementById('btn-save').onclick = async ()=>{
          const w = parseInt(document.getElementById('f-wuchs').value||0);
          const g = parseInt(document.getElementById('f-gesund').value||0);
          const r = parseInt(document.getElementById('f-reife').value||0);
          const k = document.getElementById('f-komm').value||'';
          const fileIn = document.getElementById('f-photo');
          if(fileIn.files && fileIn.files[0]){
            const f = fileIn.files[0];
            const b64 = await fileToBase64(f);
            record.photos = record.photos || [];
            record.photos.push(b64);
          }
          record.last = { wuchs:w, gesund:g, reife:r, kom:k, at: new Date().toISOString() };
          await putStock(record);
          document.getElementById('modal').style.display='none';
          refreshList();
        };
        document.getElementById('btn-close').onclick = ()=>{ document.getElementById('modal').style.display='none'; };
      })();
    }

    function fileToBase64(file){ return new Promise((res,rej)=>{ const r = new FileReader(); r.onload = ()=>res(r.result); r.onerror = e => rej(e); r.readAsDataURL(file); }); }

    document.getElementById('btn-export').onclick = async ()=>{
      const all = await getAll();
      const rows = [ ['id','row','index','lat','lon','last_wuchs','last_gesund','last_reife','last_kommentar','photo_count','created'] ];
      for(const s of all){ rows.push([s.id,s.row,s.index,s.lat,s.lon,(s.last?.wuchs||''),(s.last?.gesund||''),(s.last?.reife||''),(s.last?.kom||''),(s.photos?.length||0), s.created]); }
      const csv = rows.map(r=>r.map(c=>`"${String(c||'').replace(/"/g,'""')}"`).join(',')).join('\n');
      const blob = new Blob([csv],{type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'reben_bonitur.csv'; a.click(); URL.revokeObjectURL(url);
      setStatus('CSV exportiert');
    };

    document.getElementById('btn-clear').onclick = async ()=>{
      if(!confirm('Alle lokal gespeicherten Daten löschen?')) return;
      await clearAll();
      markersLayer.clearLayers();
      tempMarkers.forEach(m=>map.removeLayer(m)); tempMarkers = [];
      generatedPoints = [];
      refreshList();
      setStatus('Daten gelöscht');
    };

    // initial refresh
    refreshList();

  </script>
</body>
</html>
