<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Reben-Bonitur (PWA Demo)</title>  
  <!-- App-Modus aktivieren -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- App-Icons -->
  <link rel="apple-touch-icon" href="icon-192.png">

  <!-- Splashscreen -->
  <link rel="apple-touch-startup-image" href="splash.png">

  <style>
    body { margin:0; font-family:system-ui, -apple-system,Segoe UI, Roboto, "Helvetica Neue", Arial; }
    #map { height:55vh; }
    .toolbar { padding:8px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .panel { padding:8px; }
    .point { cursor:pointer; padding:6px; border-bottom:1px solid #eee; }
    input, button, select, textarea { font:inherit; padding:6px; }
    .photo-thumb { max-width:100px; max-height:80px; margin:4px; }
    .small { font-size:0.9rem; }
    .point.highlight {
    background-color: #ffeb3b !important;
    border-left: 6px solid #f59e0b;
    padding-left: 6px;
    transition: background-color 0.2s ease;
    }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>
<body>
  <div class="toolbar">
    <button id="btn-set-row">Reihe setzen (2 Punkte)</button>
    <label class="small">Stock-Abstand (m): <input id="input-spacing" type="number" value="1" min="0.1" step="0.1" style="width:70px"></label>
    <label class="small">Reihenabstand (m): <input id="input-rowspacing" type="number" value="2" min="0.1" step="0.1" style="width:70px"></label>
    <label class="small">Richtung: 
      <select id="select-dir"><option value="right">rechts</option><option value="left">links</option><option value="both">beide</option></select>
    </label>
    <button id="btn-generate">St√∂cke generieren</button>
    <button id="btn-export">Export CSV</button>
    <button id="btn-import">Import CSV</button>
    <button id="btn-clear">DB l√∂schen</button>
    <button id="btn-locate">üìç Mein Standort</button>
    <span id="status"></span>
  </div>
  <input id="csv-file" type="file" accept=".csv,text/csv" style="display:none">
  <div id="map"></div>
  <div class="panel">
    <h3>Liste (tippe Punkt auf Karte oder hier)</h3>
    <div id="list"></div>
  </div>

  <!-- Detail Modal -->
  <div id="modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.4); align-items:center; justify-content:center;">
    <div style="background:#fff; padding:12px; width:92%; max-width:480px; border-radius:8px;">
      <h3 id="modal-title">Stock</h3>
      <div id="modal-body"></div>
      <div style="display:flex; gap:8px; margin-top:8px; justify-content:flex-end;">
        <button id="btn-save">Speichern</button>
        <button id="btn-close">Schlie√üen</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    let highlightedId = null;
    // --- IndexedDB Wrapper ---
    const DB_NAME = 'reben-bonitur-v1';
    const STORE = 'stocks';
    function openDB(){
      return new Promise((res,rej)=>{
        const r = indexedDB.open(DB_NAME,1);
        r.onupgradeneeded = e => { const db = e.target.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE,{keyPath:'id'}); };
        r.onsuccess = e => res(e.target.result);
        r.onerror = e => rej(e.target.error);
      });
    }
    async function putStock(obj){ const db = await openDB(); const tx = db.transaction(STORE,'readwrite'); tx.objectStore(STORE).put(obj); return new Promise((r,rej)=>{tx.oncomplete=r;tx.onerror=rej}); }
    async function getAll(){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction(STORE,'readonly'); const req = tx.objectStore(STORE).getAll(); req.onsuccess = ()=>res(req.result); req.onerror = ()=>rej(req.error); }); }
    async function clearAll(){ const db = await openDB(); const tx = db.transaction(STORE,'readwrite'); tx.objectStore(STORE).clear(); return new Promise((r,rej)=>{tx.oncomplete=r;tx.onerror=rej}); }

    // --- Map Setup ---
    const map = L.map('map').setView([48.0, 8.0], 16);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:30}).addTo(map);
    let userLocationMarker = null;
    let userLocationCircle = null;

    document.getElementById('btn-locate').onclick = ()=>{
  if(!navigator.geolocation){
    alert('Geolocation wird von diesem Ger√§t nicht unterst√ºtzt');
    return;
  }

  setStatus('Standort wird ermittelt‚Ä¶');

  navigator.geolocation.getCurrentPosition(
    (pos)=>{
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;
      const acc = pos.coords.accuracy;

      // alte Marker entfernen
      if(userLocationMarker) map.removeLayer(userLocationMarker);
      if(userLocationCircle) map.removeLayer(userLocationCircle);

      // Marker setzen
      userLocationMarker = L.marker([lat, lon], {
        title: 'Mein Standort'
      }).addTo(map);

      // Genauigkeitskreis
      userLocationCircle = L.circle([lat, lon], {
        radius: acc
      }).addTo(map);

      // Karte zentrieren
      map.setView([lat, lon], 18);

      setStatus(`Standort gefunden (¬±${Math.round(acc)} m)`);
    },
    (err)=>{
      console.error(err);
      alert('Standort konnte nicht ermittelt werden');
    },
    {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
    }
  );
};


    let tempMarkers = [];
    let generatedPoints = [];
    const markersLayer = L.layerGroup().addTo(map);

    document.getElementById('btn-set-row').onclick = ()=>{
      tempMarkers.forEach(m=>map.removeLayer(m)); tempMarkers = [];
      map.once('click', e=>{
        const m1 = L.marker(e.latlng).addTo(map); tempMarkers.push(m1);
        map.once('click', e2=>{
          const m2 = L.marker(e2.latlng).addTo(map); tempMarkers.push(m2);
          const poly = L.polyline([m1.getLatLng(), m2.getLatLng()]).addTo(map);
          tempMarkers.push(poly);
          setStatus('Punkte gesetzt. Jetzt auf "St√∂cke generieren" klicken.');
        });
      });
      setStatus('Klicke zwei Punkte auf der Karte, um die Reihe zu definieren.');
    };

    function setStatus(s){ document.getElementById('status').textContent = s; setTimeout(()=>{ if(document.getElementById('status').textContent===s) document.getElementById('status').textContent=''; },4000); }

    function toRad(d){ return d*Math.PI/180; }
    function toDeg(d){ return d*180/Math.PI; }

    function destPoint(lat, lon, bearingDeg, distMeters){
      const R = 6378137.0;
      const br = toRad(bearingDeg);
      const lat1 = toRad(lat), lon1 = toRad(lon);
      const dR = distMeters / R;
      const lat2 = Math.asin(Math.sin(lat1)*Math.cos(dR) + Math.cos(lat1)*Math.sin(dR)*Math.cos(br));
      const lon2 = lon1 + Math.atan2(Math.sin(br)*Math.sin(dR)*Math.cos(lat1), Math.cos(dR)-Math.sin(lat1)*Math.sin(lat2));
      return [toDeg(lat2), toDeg(lon2)];
    }

    function bearingBetween(a,b){
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat); const dLon = toRad(b.lng-a.lng);
      const y = Math.sin(dLon)*Math.cos(lat2);
      const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
      return (toDeg(Math.atan2(y,x))+360)%360;
    }

    // --- Utility: offset point perpendicular by meters (approx) ---
    function offsetPoint(lat, lng, bearingDeg, offsetMeters){
      // Move perpendicular (bearing+90) by offsetMeters
      const perp = (bearingDeg + 90) % 360;
      return destPoint(lat, lng, perp, offsetMeters);
    }

    // --- Generate stocks for base row + parallels ---
    document.getElementById('btn-generate').onclick = async ()=> {
  const pts = tempMarkers.filter(p=>p instanceof L.Marker).map(m=>m.getLatLng());
  if(pts.length < 2){
    setStatus('Bitte zuerst zwei Punkte setzen.');
    return;
  }

  const baseStart = pts[0];
  const baseEnd   = pts[1];
  const spacing = parseFloat(document.getElementById('input-spacing').value) || 1;
  const rowSpacing = parseFloat(document.getElementById('input-rowspacing').value) || 2;
  const dir = document.getElementById('select-dir').value;
  const numExtra = parseInt(prompt('Wieviele zus√§tzliche parallele Reihen? (0 = nur diese)') || 0);

  const allRows = [];
  allRows.push({start:baseStart, end:baseEnd});

  const bearingBase = bearingBetween(baseStart, baseEnd);

  function pushOffset(i, side){
    const off = rowSpacing * i * side;
    const p1 = offsetPoint(baseStart.lat, baseStart.lng, bearingBase, off);
    const p2 = offsetPoint(baseEnd.lat, baseEnd.lng, bearingBase, off);
    allRows.push({
      start:{lat:p1[0], lng:p1[1]},
      end:{lat:p2[0], lng:p2[1]}
    });
  }

  for(let i=1;i<=numExtra;i++){
    if(dir==='right' || dir==='both') pushOffset(i, +1);
    if(dir==='left'  || dir==='both') pushOffset(i, -1);
  }

  generatedPoints = [];
  markersLayer.clearLayers();

  for(let rIndex=0; rIndex<allRows.length; rIndex++){
    const row = allRows[rIndex];
    const b = bearingBetween(row.start, row.end);
    const distTotal = map.distance(row.start, row.end);
    const count = Math.max(1, Math.round(distTotal / spacing) + 1);

    for(let i=0; i<count; i++){
      const d = i * spacing;
      const [lat,lon] = destPoint(row.start.lat, row.start.lng, b, d);
      const id = `R${rIndex+1}-S${i+1}`;

      const marker = L.circleMarker([lat,lon], {radius:6}).addTo(markersLayer);
      marker.__meta = {id, row:rIndex+1, index:i+1, lat, lon};

      marker.on('click', ()=> {
  highlightedId = marker.__meta.id;

  openDetail(marker.__meta);

  refreshList();   // <-- wichtig
});



      generatedPoints.push(marker.__meta);
    }
  }

  await saveInitial(generatedPoints);
  refreshList();
  setStatus(`Generiert ${generatedPoints.length} St√∂cke`);
};


    async function saveInitial(points){
      for(const p of points){
        const obj = { id: p.id, index: p.index, row: p.row, lat: p.lat, lon: p.lon, photos: [], lasts: [], created: new Date().toISOString() };
        await putStock(obj);
      }
    }

    async function refreshList(){
  const all = await getAll();
  const list = document.getElementById('list');
  list.innerHTML = '';

  all.sort((a,b)=>{
    if(a.row !== b.row) return a.row - b.row;
    return a.index - b.index;
  });

  for(const s of all){
    const el = document.createElement('div');
    el.id = `list-${s.id}`;
    el.className = 'point';
    el.textContent = `${s.id} ‚Äî R${s.row} S${s.index}`;
    el.onclick = ()=> openDetail(s);

    // ‚≠ê HIGHLIGHT HIER (nach Render!)
    if(s.id === highlightedId){
      el.classList.add('highlight');

      // Scroll erst NACH DOM-Aufbau
      setTimeout(()=>{
        el.scrollIntoView({ behavior:'smooth', block:'center' });
      }, 30);

      // Highlight sp√§ter entfernen
      setTimeout(()=>{
        el.classList.remove('highlight');
        highlightedId = null;
      }, 15000);
    }

    list.appendChild(el);
  }
}


    // modal / detail
    function openDetail(meta){
  (async () => {

    // Datensatz laden
    const all = await getAll();
    const record = all.find(x => x.id === meta.id) || meta;

    // letzte Begehung (oder leere Defaults)
    const last = record.lasts?.length
      ? record.lasts[record.lasts.length - 1]
      : { wuchs:'', gesund:'', reife:'', kom:'' };

    // Modal-Titel
    document.getElementById('modal-title').textContent = record.id || 'Stock';

    // Modal-Body
    const body = document.getElementById('modal-body');
    body.innerHTML = `
      <div>Row: ${record.row ?? ''} ‚Äî Index: ${record.index ?? ''}</div>
      <div>Lat: ${record.lat?.toFixed(6) ?? ''} Lon: ${record.lon?.toFixed(6) ?? ''}</div>

      <label>Wuchs (1‚Äì5):
        <input id="f-wuchs" type="number" min="1" max="5" value="${last.wuchs}">
      </label><br>

      <label>Gesundheit (1‚Äì5):
        <input id="f-gesund" type="number" min="1" max="5" value="${last.gesund}">
      </label><br>

      <label>Reife (1‚Äì5):
        <input id="f-reife" type="number" min="1" max="5" value="${last.reife}">
      </label><br>

      <label>Kommentar:<br>
        <textarea id="f-komm">${last.kom || ''}</textarea>
      </label><br>

      <label>Foto:
        <input id="f-photo" type="file" accept="image/*" capture="environment">
      </label>

      <div id="thumbs"></div>
    `;

    // Fotos anzeigen
    const thumbs = document.getElementById('thumbs');
    if (record.photos?.length){
      for (const p of record.photos){
        const img = document.createElement('img');
        img.src = p;
        img.className = 'photo-thumb';
        thumbs.appendChild(img);
      }
    }

    // Modal √∂ffnen
    document.getElementById('modal').style.display = 'flex';

    // SPEICHERN
    document.getElementById('btn-save').onclick = async () => {
      const w = parseInt(document.getElementById('f-wuchs').value) || 0;
      const g = parseInt(document.getElementById('f-gesund').value) || 0;
      const r = parseInt(document.getElementById('f-reife').value) || 0;
      const k = document.getElementById('f-komm').value || '';

      // Foto
      const fileIn = document.getElementById('f-photo');
      if (fileIn.files && fileIn.files[0]){
        const b64 = await fileToBase64(fileIn.files[0]);
        record.photos = record.photos || [];
        record.photos.push(b64);
      }

      // neue Begehung anh√§ngen
      record.lasts = record.lasts || [];
      record.lasts.push({
        wuchs: w,
        gesund: g,
        reife: r,
        kom: k,
        at: new Date().toISOString()
      });

      await putStock(record);
      document.getElementById('modal').style.display = 'none';
      refreshList();
    };

    document.getElementById('btn-close').onclick = () => {
      document.getElementById('modal').style.display = 'none';
    };

  })();
}

   


    function fileToBase64(file){ return new Promise((res,rej)=>{ const r = new FileReader(); r.onload = ()=>res(r.result); r.onerror = e => rej(e); r.readAsDataURL(file); }); }

    document.getElementById('btn-export').onclick = async () => {
  const all = await getAll();

  all.sort((a,b)=> a.row - b.row || a.index - b.index);

  const maxBegehungen = Math.max(...all.map(s => s.lasts.length));

  const header = ['id','row','index','lat','lon','created'];
  for (let i=0;i<maxBegehungen;i++){
    header.push('wuchs','gesund','reife','kommentar','created');
  }

  const rows = [header];

  for (const s of all) {
    const r = [
      s.id, s.row, s.index,
      s.lat.toFixed(6),
      s.lon.toFixed(6),
      new Date(s.created).toLocaleDateString('de-DE')
    ];

    for (let i=0;i<maxBegehungen;i++){
      const b = s.lasts[i] || {};
      r.push(
        b.wuchs || '',
        b.gesund || '',
        b.reife || '',
        b.kom || '',
        b.at ? new Date(b.at).toLocaleDateString('de-DE') : ''
      );
    }

    rows.push(r);
  }

  const csv = rows.map(r =>
    r.map(c => `"${String(c).replace(/"/g,'""')}"`).join(';')
  ).join('\n');

  downloadCSV(csv, 'reben_bonitur.csv');
};

function downloadCSV(text, name){
  const blob = new Blob([text], {type:'text/csv'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
}


// Sortierung wie in der Weboberfl√§che


    document.getElementById('btn-clear').onclick = async ()=>{
      if(!confirm('Alle lokal gespeicherten Daten l√∂schen?')) return;
      await clearAll();
      markersLayer.clearLayers();
      tempMarkers.forEach(m=>map.removeLayer(m)); tempMarkers = [];
      generatedPoints = [];
      refreshList();
      setStatus('Daten gel√∂scht');
    };

    // initial refresh
    refreshList();
    document.getElementById('btn-import').onclick = () => {
  document.getElementById('csv-file').click();
};

document.getElementById('csv-file').addEventListener('change', async ev => {
  const file = ev.target.files[0];
  if (!file) return;

  const text = await file.text();
  const lines = text.trim().split('\n');
  if (lines.length < 2) {
    setStatus('CSV leer');
    return;
  }

  const headers = lines[0].split(';').map(h => h.replace(/"/g,'').trim());

  // Basis-Spalten
  const baseCols = ['id','row','index','lat','lon','created'];
  const baseCount = baseCols.length;

  // Anzahl Begehungen global bestimmen
  const begehungCount = Math.floor((headers.length - baseCount) / 5);
  if (begehungCount < 0) {
  setStatus('CSV-Header ung√ºltig');
  return;
}

  const neueBegehung = confirm('Neue Begehung anh√§ngen?');

  await clearAll();
  markersLayer.clearLayers();

  for (let i = 1; i < lines.length; i++) {
    if (!lines[i].trim()) continue;

    const cells = lines[i].split(';').map(c => c.replace(/"/g,'').trim());

    const stock = {
      id: cells[0],
      row: parseInt(cells[1]) || 0,
      index: parseInt(cells[2]) || 0,
      lat: parseFloat(cells[3]),
      lon: parseFloat(cells[4]),
      created: parseDate(cells[5]).toISOString(),
      photos: [],
      lasts: []
    };

    let offset = baseCount;

    for (let b = 0; b < begehungCount; b++) {
      stock.lasts.push({
        wuchs:  parseInt(cells[offset++]) || 0,
        gesund: parseInt(cells[offset++]) || 0,
        reife:  parseInt(cells[offset++]) || 0,
        kom:    cells[offset++] || '',
        at:     parseDate(cells[offset++]).toISOString()
      });
    }

    if (neueBegehung) {
      stock.lasts.push({
        wuchs: 0, gesund: 0, reife: 0, kom: '',
        at: new Date().toISOString()
      });
    }

    await putStock(stock);

    const m = L.circleMarker([stock.lat, stock.lon], { radius:6 }).addTo(markersLayer);
    m.__meta = stock;
    m.on('click', () => openDetail(stock));
  }

  refreshList();
  setStatus(`CSV importiert (${begehungCount + (neueBegehung ? 1 : 0)} Begehungen)`);
  ev.target.value = '';
});

function parseDate(v){
  if (!v) return new Date();
  if (v.includes('.')) {
    const [d,m,y] = v.split('.').map(Number);
    return new Date(y, m-1, d);
  }
  const d = new Date(v);
  return isNaN(d) ? new Date() : d;
}


  </script>
</body>
</html>
