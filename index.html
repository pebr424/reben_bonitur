
<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Reben-Bonitur (PWA Demo)</title>  
  <!-- App-Modus aktivieren -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- App-Icons -->
  <link rel="apple-touch-icon" href="icon-192.png">

  <!-- Splashscreen -->
  <link rel="apple-touch-startup-image" href="splash.png">

  <style>
    body { margin:0; font-family:system-ui, -apple-system,Segoe UI, Roboto, "Helvetica Neue", Arial; }
    #map { height:55vh; }
    .toolbar { padding:8px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .panel { padding:8px; }
    .point { cursor:pointer; padding:6px; border-bottom:1px solid #eee; }
    input, button, select, textarea { font:inherit; padding:6px; }
    .photo-thumb { max-width:100px; max-height:80px; margin:4px; }
    .small { font-size:0.9rem; }
    .point.highlight {
    background-color: #ffeb3b !important;
    border-left: 6px solid #f59e0b;
    padding-left: 6px;
    transition: background-color 0.2s ease;
    }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>
<body>
    <div id="top-bar" style="position:fixed; top:0; left:0; right:0; background:#fff; padding:6px 12px; border-bottom:1px solid #ccc; z-index:1000; display:flex; gap:8px;">
        <button id="btn-top">Top</button>
        <select id="select-wingert">
          <option value="ALL">Alle Wingert</option>
        </select>
        <button id="btn-row">Reihe</button>
        <button id="btn-stock">Stock</button>
      </div>
      <div style="height:50px;"></div> <!-- Platzhalter, damit die Toolbar den Inhalt nicht √ºberlappt -->
  <div class="toolbar">
    <button id="btn-set-row">Reihe setzen (2 Punkte)</button>
    <label class="small">Stock-Abstand (m): <input id="input-spacing" type="number" value="1" min="0.1" step="0.1" style="width:70px"></label>
    <label class="small">Reihenabstand (m): <input id="input-rowspacing" type="number" value="2" min="0.1" step="0.1" style="width:70px"></label>
    <label class="small">Richtung: 
      <select id="select-dir"><option value="right">rechts</option><option value="left">links</option><option value="both">beide</option></select>
    </label>
    <button id="btn-generate">St√∂cke generieren</button>
    <button id="btn-export">Export CSV</button>
    <button id="btn-import">Import CSV</button>
    <button id="btn-clear">DB l√∂schen</button>
    <button id="btn-locate">üìç Mein Standort</button>
    <span id="status"></span>
  </div>
  <input id="csv-file" type="file" accept=".csv,.zip" style="display:none">
  <div id="map"></div>
  <div class="panel">
    <h3>Liste (tippe Punkt auf Karte oder hier)</h3>
    <div id="list"></div>
  </div>
 
  

  <!-- Detail Modal -->
  <div id="modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.4); align-items:center; justify-content:center;">
    <div style="background:#fff; padding:12px; width:92%; max-width:480px; border-radius:8px;">
      <h3 id="modal-title">Stock</h3>
      <div id="modal-body"></div>
      <div style="display:flex; gap:8px; margin-top:8px; justify-content:flex-end;">
        <button id="btn-save">Speichern</button>
        <button id="btn-close">Schlie√üen</button>
      </div>
    </div>
  </div>
 
  

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <script>
   
   let currentWingert = 'ALL';
const wingertsSet = new Set();


    let highlightedId = null;
    // --- IndexedDB Wrapper ---
    const DB_NAME = 'reben-bonitur-v1';
    const STORE = 'stocks';
    function openDB(){
      return new Promise((res,rej)=>{
        const r = indexedDB.open(DB_NAME,1);
        r.onupgradeneeded = e => { const db = e.target.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE,{keyPath:'id'}); };
        r.onsuccess = e => res(e.target.result);
        r.onerror = e => rej(e.target.error);
      });
    }
    async function putStock(obj){ const db = await openDB(); const tx = db.transaction(STORE,'readwrite'); tx.objectStore(STORE).put(obj); return new Promise((r,rej)=>{tx.oncomplete=r;tx.onerror=rej}); }
    async function getAll(){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction(STORE,'readonly'); const req = tx.objectStore(STORE).getAll(); req.onsuccess = ()=>res(req.result); req.onerror = ()=>rej(req.error); }); }
    async function clearAll(){ const db = await openDB(); const tx = db.transaction(STORE,'readwrite'); tx.objectStore(STORE).clear(); return new Promise((r,rej)=>{tx.oncomplete=r;tx.onerror=rej}); }

    // --- Map Setup ---
    const map = L.map('map').setView([48.0, 8.0], 16);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:30}).addTo(map);
    let userLocationMarker = null;
    let userLocationCircle = null;

    document.getElementById('btn-locate').onclick = ()=>{
  if(!navigator.geolocation){
    alert('Geolocation wird von diesem Ger√§t nicht unterst√ºtzt');
    return;
  }

  setStatus('Standort wird ermittelt‚Ä¶');

  navigator.geolocation.getCurrentPosition(
    (pos)=>{
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;
      const acc = pos.coords.accuracy;

      // alte Marker entfernen
      if(userLocationMarker) map.removeLayer(userLocationMarker);
      if(userLocationCircle) map.removeLayer(userLocationCircle);

      // Marker setzen
      userLocationMarker = L.marker([lat, lon], {
        title: 'Mein Standort'
      }).addTo(map);

      // Genauigkeitskreis
      userLocationCircle = L.circle([lat, lon], {
        radius: acc
      }).addTo(map);

      // Karte zentrieren
      map.setView([lat, lon], 18);

      setStatus(`Standort gefunden (¬±${Math.round(acc)} m)`);
    },
    (err)=>{
      console.error(err);
      alert('Standort konnte nicht ermittelt werden');
    },
    {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
    }
  );
};


    let tempMarkers = [];
    let generatedPoints = [];
    const markersLayer = L.layerGroup().addTo(map);

    document.getElementById('btn-top').onclick = () => window.scrollTo({ top: 0, behavior: 'smooth' });

document.getElementById('btn-row').onclick = async () => {
  const rowNum = parseInt(prompt('Welche Reihe?'));
  if(isNaN(rowNum)) return;

  const all = await getAll();
  const record = all.find(r => (currentWingert === 'ALL' || r.wingert === currentWingert) && r.row === rowNum);
  if(!record){ alert('Reihe nicht gefunden'); return; }

  document.getElementById(`list-${record.id}`).scrollIntoView({ behavior:'smooth', block:'center' });
  highlightedId = record.id;
  refreshList();
};

document.getElementById('btn-stock').onclick = async () => {
  const rowNum = parseInt(prompt('Reihe des Stocks?'));
  if(isNaN(rowNum)) return;
  const stockNum = parseInt(prompt('Stocknummer?'));
  if(isNaN(stockNum)) return;

  const all = await getAll();
  const record = all.find(r => (currentWingert === 'ALL' || r.wingert === currentWingert) && r.row === rowNum && r.index === stockNum);
  if(!record){ alert('Stock nicht gefunden'); return; }

  document.getElementById(`list-${record.id}`).scrollIntoView({ behavior:'smooth', block:'center' });
  highlightedId = record.id;
  openDetail(record);
  refreshList();
};


    document.getElementById('btn-set-row').onclick = ()=>{
      tempMarkers.forEach(m=>map.removeLayer(m)); tempMarkers = [];
      map.once('click', e=>{
        const m1 = L.marker(e.latlng).addTo(map); tempMarkers.push(m1);
        map.once('click', e2=>{
          const m2 = L.marker(e2.latlng).addTo(map); tempMarkers.push(m2);
          const poly = L.polyline([m1.getLatLng(), m2.getLatLng()]).addTo(map);
          tempMarkers.push(poly);
          setStatus('Punkte gesetzt. Jetzt auf "St√∂cke generieren" klicken.');
        });
      });
      setStatus('Klicke zwei Punkte auf der Karte, um die Reihe zu definieren.');
    };

    function setStatus(s){ document.getElementById('status').textContent = s; setTimeout(()=>{ if(document.getElementById('status').textContent===s) document.getElementById('status').textContent=''; },4000); }

    function toRad(d){ return d*Math.PI/180; }
    function toDeg(d){ return d*180/Math.PI; }

    function destPoint(lat, lon, bearingDeg, distMeters){
      const R = 6378137.0;
      const br = toRad(bearingDeg);
      const lat1 = toRad(lat), lon1 = toRad(lon);
      const dR = distMeters / R;
      const lat2 = Math.asin(Math.sin(lat1)*Math.cos(dR) + Math.cos(lat1)*Math.sin(dR)*Math.cos(br));
      const lon2 = lon1 + Math.atan2(Math.sin(br)*Math.sin(dR)*Math.cos(lat1), Math.cos(dR)-Math.sin(lat1)*Math.sin(lat2));
      return [toDeg(lat2), toDeg(lon2)];
    }

    function bearingBetween(a,b){
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat); const dLon = toRad(b.lng-a.lng);
      const y = Math.sin(dLon)*Math.cos(lat2);
      const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
      return (toDeg(Math.atan2(y,x))+360)%360;
    }

    // --- Utility: offset point perpendicular by meters (approx) ---
    function offsetPoint(lat, lng, bearingDeg, offsetMeters){
      // Move perpendicular (bearing+90) by offsetMeters
      const perp = (bearingDeg + 90) % 360;
      return destPoint(lat, lng, perp, offsetMeters);
    }

    // --- Generate stocks for base row + parallels ---
    document.getElementById('btn-generate').onclick = async ()=> {

let wingertName = prompt('Name des Wingerts?');
if (!wingertName) {
  setStatus('Generieren abgebrochen (kein Wingert-Name)');
  return;
}
wingertName = wingertName.trim();

wingertsSet.add(wingertName);
refreshWingertSelect([...wingertsSet]);
currentWingert = wingertName;
document.getElementById('select-wingert').value = wingertName;
localStorage.setItem('lastWingert', wingertName);


  const pts = tempMarkers.filter(p=>p instanceof L.Marker).map(m=>m.getLatLng());
  if(pts.length < 2){
    setStatus('Bitte zuerst zwei Punkte setzen.');
    return;
  }

  const baseStart = pts[0];
  const baseEnd   = pts[1];
  const spacing = parseFloat(document.getElementById('input-spacing').value) || 1;
  const rowSpacing = parseFloat(document.getElementById('input-rowspacing').value) || 2;
  const dir = document.getElementById('select-dir').value;
  const numExtra = parseInt(prompt('Wieviele zus√§tzliche parallele Reihen? (0 = nur diese)') || 0);

  const allRows = [];
  allRows.push({start:baseStart, end:baseEnd});

  const bearingBase = bearingBetween(baseStart, baseEnd);

  function pushOffset(i, side){
    const off = rowSpacing * i * side;
    const p1 = offsetPoint(baseStart.lat, baseStart.lng, bearingBase, off);
    const p2 = offsetPoint(baseEnd.lat, baseEnd.lng, bearingBase, off);
    allRows.push({
      start:{lat:p1[0], lng:p1[1]},
      end:{lat:p2[0], lng:p2[1]}
    });
  }

  for(let i=1;i<=numExtra;i++){
    if(dir==='right' || dir==='both') pushOffset(i, +1);
    if(dir==='left'  || dir==='both') pushOffset(i, -1);
  }

  generatedPoints = [];
  markersLayer.clearLayers();

  for(let rIndex=0; rIndex<allRows.length; rIndex++){
    const row = allRows[rIndex];
    const b = bearingBetween(row.start, row.end);
    const distTotal = map.distance(row.start, row.end);
    const count = Math.max(1, Math.round(distTotal / spacing) + 1);

    for(let i=0; i<count; i++){
      const d = i * spacing;
      const [lat,lon] = destPoint(row.start.lat, row.start.lng, b, d);
      const shortId = `R${rIndex+1}-S${i+1}`;
      const fullId  = `${wingertName}-${shortId}`;

      const marker = L.circleMarker([lat,lon], {radius:6}).addTo(markersLayer);
      marker.__meta = {
  id: fullId,      // eindeutig f√ºr DB, Liste, Scroll
  row: rIndex+1,
  index: i+1,
  lat,
  lon,
  wingert: wingertName
};

    marker.on('click', () => focusStock(marker.__meta, true));




      generatedPoints.push(marker.__meta);
    }
  }

  await saveInitial(generatedPoints);
  refreshList();
  setStatus(`Generiert ${generatedPoints.length} St√∂cke`);
};


async function saveInitial(points){
  for(const p of points){
    const obj = {
      id: p.id,         // ‚úÖ einfach p.id, nicht nochmal Wingert dranh√§ngen
      wingert: p.wingert,
      index: p.index,
      row: p.row,
      lat: p.lat,
      lon: p.lon,
      photos: [],
      lasts: [],
      created: new Date().toISOString()
    };
    await putStock(obj);
  }
}



    async function refreshList(){
  const all = await getAll();
  const list = document.getElementById('list');
  list.innerHTML = '';

  // Wingert-Filter
  const filtered = all.filter(s => currentWingert === 'ALL' || s.wingert === currentWingert);

  filtered.sort((a, b) => {
  if (a.wingert !== b.wingert) {
    return a.wingert.localeCompare(b.wingert, 'de');
  }
  if (a.row !== b.row) {
    return a.row - b.row;
  }
  return a.index - b.index;
});


  for(const s of filtered){
    const el = document.createElement('div');
    el.id = `list-${s.id}`;
    el.className = 'point';
    el.textContent = `${s.wingert} ‚Äî R${s.row} S${s.index}`;
    el.onclick = ()=> focusStock(s, true);

    if(s.id === highlightedId){
  el.classList.add('highlight');
}


    list.appendChild(el);
  }
}

async function focusStock(stock, openModal = true){
  // 1. Wingert setzen
  if (stock.wingert && currentWingert !== stock.wingert){
    currentWingert = stock.wingert;
    const sel = document.getElementById('select-wingert');
    if (sel) sel.value = stock.wingert;
  }

  // 2. Liste neu aufbauen
  await refreshList();

  // 3. Highlight setzen
  highlightedId = stock.id;

  // 4. Scrollen
  setTimeout(() => {
    const el = document.getElementById(`list-${stock.id}`);
    if (el){
      el.scrollIntoView({ behavior:'smooth', block:'center' });
      el.classList.add('highlight');
    }
  }, 50);

  // 5. Modal √∂ffnen
  if (openModal) openDetail(stock);
}



    // modal / detail
    function openDetail(meta){
  (async () => {

    // Datensatz laden
    const all = await getAll();
    const record = all.find(x => x.id === meta.id) || meta;

    // letzte Begehung (oder leere Defaults)
    const last = record.lasts?.length
      ? record.lasts[record.lasts.length - 1]
      : { wuchs:'', gesund:'', reife:'', kom:'' };

    // Modal-Titel
    document.getElementById('modal-title').textContent = record.id || 'Stock';

    // Modal-Body
    const body = document.getElementById('modal-body');
    body.innerHTML = `
      <div>Row: ${record.row ?? ''} ‚Äî Index: ${record.index ?? ''}</div>
      <div>Lat: ${record.lat?.toFixed(6) ?? ''} Lon: ${record.lon?.toFixed(6) ?? ''}</div>

      <label>Wuchs (1‚Äì5):
        <input id="f-wuchs" type="number" min="1" max="5" value="${last.wuchs}">
      </label><br>

      <label>Gesundheit (1‚Äì5):
        <input id="f-gesund" type="number" min="1" max="5" value="${last.gesund}">
      </label><br>

      <label>Reife (1‚Äì5):
        <input id="f-reife" type="number" min="1" max="5" value="${last.reife}">
      </label><br>

      <label>Kommentar:<br>
        <textarea id="f-komm">${last.kom || ''}</textarea>
      </label><br>

      <label>Foto:
        <input id="f-photo" type="file" accept="image/*" capture="environment">
      </label>

      <div id="thumbs"></div>
    `;

    // Fotos anzeigen
    const thumbs = document.getElementById('thumbs');
    if (record.photos?.length){
      for (const p of record.photos){
        const img = document.createElement('img');
        img.src = p;
        img.className = 'photo-thumb';
        thumbs.appendChild(img);
      }
    }

    // Modal √∂ffnen
    document.getElementById('modal').style.display = 'flex';

    // SPEICHERN
    document.getElementById('btn-save').onclick = async () => {
      const w = parseInt(document.getElementById('f-wuchs').value) || 0;
      const g = parseInt(document.getElementById('f-gesund').value) || 0;
      const r = parseInt(document.getElementById('f-reife').value) || 0;
      const k = document.getElementById('f-komm').value || '';

      // Foto
      const fileIn = document.getElementById('f-photo');
      if (fileIn.files && fileIn.files[0]){
        const b64 = await fileToBase64(fileIn.files[0]);
        record.photos = record.photos || [];
        record.photos.push(b64);
      }

      // neue Begehung anh√§ngen
      record.lasts = record.lasts || [];
      record.lasts.push({
        wuchs: w,
        gesund: g,
        reife: r,
        kom: k,
        at: new Date().toISOString()
      });

      await putStock(record);
      document.getElementById('modal').style.display = 'none';
      refreshList();
    };

    document.getElementById('btn-close').onclick = () => {
      document.getElementById('modal').style.display = 'none';
    };

  })();
}

   


    function fileToBase64(file){ return new Promise((res,rej)=>{ const r = new FileReader(); r.onload = ()=>res(r.result); r.onerror = e => rej(e); r.readAsDataURL(file); }); }

    document.getElementById('btn-export').onclick = async () => {
  const allStocks = await getAll();

  // üîπ Wingert-Filter anwenden
  const all = allStocks.filter(s =>
    currentWingert === 'ALL' || s.wingert === currentWingert
  );

  if (!all.length){
    alert('Kein Wingert zum Exportieren ausgew√§hlt');
    return;
  }


  all.sort((a,b)=> a.row - b.row || a.index - b.index);

  const maxBegehungen = Math.max(...all.map(s => s.lasts.length));

  const header = ['id','row','index','lat','lon','created'];
  for (let i=0;i<maxBegehungen;i++){
    header.push('wuchs','gesund','reife','kommentar','created');
  }

  const rows = [header];

  for (const s of all) {
    const r = [
      s.id, s.row, s.index,
      s.lat.toFixed(6),
      s.lon.toFixed(6),
      new Date(s.created).toLocaleDateString('de-DE')
    ];

    for (let i=0;i<maxBegehungen;i++){
      const b = s.lasts[i] || {};
      r.push(
        b.wuchs || '',
        b.gesund || '',
        b.reife || '',
        b.kom || '',
        b.at ? new Date(b.at).toLocaleDateString('de-DE') : ''
      );
    }

    rows.push(r);
  }

  const csv = rows.map(r =>
  r.map(c => `"${String(c).replace(/"/g,'""')}"`).join(';')
).join('\n');

// üìÖ Datum YYYY-MM-DD
const date = new Date().toISOString().slice(0, 10);

// üè∑Ô∏è Dateiname aus aktuellem Wingert
const filename =
  currentWingert === 'ALL'
    ? `alle-wingerte-${date}.csv`
    : `${currentWingert}-${date}.csv`;

downloadCSV(csv, filename);

};

function downloadCSV(text, name){
  const blob = new Blob([text], {type:'text/csv'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
}


// Sortierung wie in der Weboberfl√§che


    document.getElementById('btn-clear').onclick = async ()=>{
      if(!confirm('Alle lokal gespeicherten Daten l√∂schen?')) return;
      await clearAll();
      markersLayer.clearLayers();
      tempMarkers.forEach(m=>map.removeLayer(m)); tempMarkers = [];
      generatedPoints = [];
      refreshList();
      setStatus('Daten gel√∂scht');
    };

    // initial refresh
    refreshList();
    document.getElementById('btn-import').onclick = () => {
  document.getElementById('csv-file').click();
};


function refreshWingertSelect(wingerts){
  const sel = document.getElementById('select-wingert');
  if(!sel) return;
  sel.innerHTML = '<option value="ALL">Alle Wingert</option>';
  wingerts.forEach(w => {
    const opt = document.createElement('option');
    opt.value = w;         // ‚úÖ nur Wingert-Name
    opt.textContent = w;
    sel.appendChild(opt);
  });
}



function parseDate(v){
  if (!v) return new Date();
  if (v.includes('.')) {
    const [d,m,y] = v.split('.').map(Number);
    return new Date(y, m-1, d);
  }
  const d = new Date(v);
  return isNaN(d) ? new Date() : d;
}
async function importZip(file){
  const zip = await JSZip.loadAsync(file);

  const csvFiles = Object.values(zip.files)
    .filter(f => !f.dir && f.name.toLowerCase().endsWith('.csv'));

  if (!csvFiles.length){
    setStatus('Keine CSV-Dateien im ZIP gefunden');
    return;
  }

  const neueBegehung = confirm(
    `ZIP enth√§lt ${csvFiles.length} CSV-Dateien.\n` +
    `Als neue Begehungen anh√§ngen?`
  );

  for (const f of csvFiles){
    const text = await f.async('string');
    await importCsvText(await file.text(), null, file.name);

  }

  refreshList();
  setStatus(`ZIP importiert (${csvFiles.length} CSVs)`);
}

async function importCsvText(text, neueBegehungOverride = null, sourceName = ''){
  const lines = text.trim().split('\n');
  if (lines.length < 2) return;
  const wingertName = sourceName.replace(/\.csv$/i, '');
wingertsSet.add(wingertName);
refreshWingertSelect([...wingertsSet]);
const sel = document.getElementById('select-wingert');
if(sel) sel.value = wingertName;

refreshList();

  let neueBegehung = neueBegehungOverride;
  if (neueBegehung === null){
    neueBegehung = confirm('Neue Begehung anh√§ngen?');
  }

  for (let i=1;i<lines.length;i++){
    if (!lines[i].trim()) continue;

    const cells = lines[i].split(';').map(c => c.replace(/"/g,'').trim());
    



    const stock = {
  id: `${wingertName}-${cells[0]}`, // Wingert-R1-S3
  wingert: wingertName,
  row: parseInt(cells[1]),
  index: parseInt(cells[2]),
  lat: parseFloat(cells[3]),
  lon: parseFloat(cells[4]),
  created: parseDate(cells[5]).toISOString(),
  photos: [],
  lasts: []
};


   
    const baseCols = 6; // id,row,index,lat,lon,created
const begehungCount = Math.floor((cells.length - baseCols) / 5);

let offset = baseCols;
for (let b=0; b<begehungCount; b++){
  stock.lasts.push({
    wuchs:  parseInt(cells[offset++]) || 0,
    gesund: parseInt(cells[offset++]) || 0,
    reife:  parseInt(cells[offset++]) || 0,
    kom:    cells[offset++] || '',
    at:     parseDate(cells[offset++]).toISOString()
  });
}


    if (neueBegehung){
      stock.lasts.push({
        wuchs:0, gesund:0, reife:0, kom:'',
        at:new Date().toISOString()
      });
    }

    await putStock(stock);
    
    const m = L.circleMarker([stock.lat, stock.lon], { radius:6 }).addTo(markersLayer);
m.__meta = stock;
m.on('click', () => focusStock(m.__meta, true));

  }
}
document.getElementById('csv-file').addEventListener('change', async ev => {
  const file = ev.target.files[0];
  if (!file) return;

  if (file.name.toLowerCase().endsWith('.zip')) {
    await importZip(file);
  } else {
    await importCsvText(await file.text());
  }

  ev.target.value = '';
});

document.getElementById('select-wingert').addEventListener('change', (e) => {
  currentWingert = e.target.value;
  localStorage.setItem('lastWingert', currentWingert);
  const lastWingert = localStorage.getItem('lastWingert');
if (lastWingert){
  currentWingert = lastWingert;
  const sel = document.getElementById('select-wingert');
  if (sel) sel.value = lastWingert;
}

  refreshList();
});


  </script>
</body>
</html>
